---
layout: post_layout
title: Pro JPA2 读书笔记系列(三)
time: 2016年08月28日 星期六
location: 济南
pulished: true
excerpt_separator: "#"
---

本章内容不做过多介绍.请阅读原文.

## 3.6 事务管理
与任何其他类型的企业应用程序相比,使用持久化的应用程序需要更加仔细地注意事务管理的问题.事务何时开始,何时结束以及实体管理器如何参与容器托管的事务,都是开发人员使用JPA的重要主题.(事务的高级主题推荐阅读Java Transaction Processing和Principles of Transaction Processing)
* 3.6.1 事务概述
  事务是用于组合一系列操作的一个抽象.一旦分组在一起,将操作集当作单个单元,并且所有的操作必须都成功或者都不成功.
  事务的基础属性:

  * 原子性(atomicity): 在一个事务中的所有操作或者都成功或者都不成功.每个操作的成功都关系到整个组的成功.
  * 一致性(consistency): 事务结束的结果状态遵循一组定义数据可接受性的规则.整个系统的数据是否合法或有效取决于系统的其余数据.
  * 隔离性(isolation): 在事务中进行的更改仅对进行更改的事务可见.一旦事务提交了更改,那么它们自动对于其他事务可见.
  * 持久性(durability):事务中所作出的更改在事务完成之后将继续保持.

  满足所欲偶这些需求的事务成为ACID事务.
  并非所有的事务都是ACID事务(例如:分布式事务),在满足ACID属性时经常会采取某种灵活性策略.

## 3.6.2 Java中的企业事务
* 事务划界

  每一个事务都有一个开始和结束.开始一个事务将允许后续操作成为相同事务的一部分,直至事务完成.事务可以以两种方式之一完成.可以提交它们,也可以回滚.
  引起一个事务开始或完成的行为成为事务划界(transaction demarcation).不正确的事务划界是性能退化的最常见的来源之一.
  资源本地事务总是显式地由应用程序进行划界,而容器事务既可以由容器自动划界,也可以通过使用支持应用程序划界的JTA接口进行划界.
  当容器接管事务划界责任时,我们称之为容器托管(container-managed)的事务管理;
  当应用程序负责划界时,我们称之为bean托管(bean-managed)的事务管理.
* 容器托管的事务

  可以通过一些元数据注解来确定事务需求,并且可以在方法执行的粒度上对容器托管的事务进行配置.
  一个bean通过一个或多个方法调用另一个bean的现象很常见.在这种情况下,不会提交因为调用方法而启动的事务,因为该调用方法直到它所调用的第二个bean完成之后才会完成.这就是需要设置以定义:当方法在一个特定的事务上下文中调用时,容器应该如何行为.
  可定义的事务特性选项如下:

  * MANDATORY(强制) : 如果把该特性指定给一个方法,那么当调用该方法时,预计一个事务已经启动并处于活动状态.如果不存在活动的事务,那么将抛出一个异常.很少使用这个特性,但是当预计一个事务已经启动时,它可以作为一个开发工具以捕获事务划界的错误.
  * REQUIRED(必需): 这个特性是最常见的情况,此时预计方法将处在一个事务中.容器确保事务对于该方法而言是活动的.如果一个事务已经是活动的,那么使用该方法;如果事务不存在,那么创建一个新事务以执行该方法.
  * REQUIRES_NEW(必需新): 就是说每次执行这个方法,都会产生一个新的事务.
  * SUPPORTS(支持): 标记为支持的方法不依赖于事务,但是如果事务存在的话,那么它将容忍运行在该事务当中.这将指示该方法不访问任何事务资源.
  * NOT_SUPPORTED(不支持): 标记为不支持事务的方法,如果调用方法时存在一个活动事务,那么将导致容器暂停当前事务.这意味着该方法不执行事务操作,但当其他方法可能不合期望地影响到事务结果时,可能会导致失败.此特性不常用.
  * NEVER(永远不):标记为永远不支持事务的方法,如果当电泳该方法时存在活动的事务,那么将导致容器抛出异常.

* bean托管的事务
  bean托管的事务(Bean-Managed Transaction,BMT).使用BMT的bean必须确保一旦已经启动了一个事务,就必须在启动它的方法返回之前完成它.(考虑多线程). 不这么做将导致容器自动回滚事务并抛出一个异常.
  由应用程序而不是由容器托管事务的一个不利之处在于它们不会传播到由另一个BMT bean调用的方法.
