<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>spring-data-jpa 中文文档(1)</title>

	<link rel="shortcut icon" href="/styles/images/favicon.jpg">
	<link rel="icon" href="/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/styles/css/index.css">
	<link rel="stylesheet" href="/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="canonical" href="/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(1)/">
	<link rel="alternate" type="application/rss+xml" title="阳光如初." href="/feed.xml">

	<meta name="description" content="阳光如初;sunshineasbefore;个人博客;怀揣梦想,永不止步;">

	<script src="/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0];
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>


  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand">
        <img src="/styles/images/logo.jpg">
      </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a href="/">主页</a>
        </li>
        <li>
          <a href="/categories/">分类</a>
        </li>
        <li>
          <a href="/tag">标签</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
          <a href="https://github.com/sunshineasbefore">Github</a>
        </li>
      </ul>
    </nav>
  </div>
</header>

    <div class="docs-header" id="content">
  <div class="container">
  	
  		<!--
		    <h1>spring-data-jpa 中文文档(1)</h1>
		    <p>Post on Aug 28, 2016 by <a href="/about">sunshineasbefore</a></p>
		-->
		    <h3>怀揣梦想,永不止步!</h3>
    
  </div>
</div>

    
      
<div class="banner">
  <div class="container">
  	
    	<a href="/categories/#JPA-ref">JPA</a>	/
    	<a href="/tag/#JPA-ref">JPA</a>
    
  </div>
</div>

    

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-3">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
<!--
    
      
      
      
      

      
        <li><a href="#year_2016">2016</a>
          <ul class="nav">
            <li><a href="#month_2016_October">October</a></li>
      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_September">September</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
              <li><a href="#month_2016_August">August</a></li>
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            
          
        
      
    
      
      
      
      

      

      
            </ul>
          </li>
      
    
-->
  </ul>
</div> 
      </div>
    </div>
    <div class="col-md-9" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">spring-data-jpa 中文文档(1)</h1>
              <!--
                <p class="post-meta">Aug 28, 2016</p>
              -->
              <div class="meta">Posted on <span class="postdate">Aug 28, 2016</span> By <a target="_blank" href="http://www.veryjava.cn">sunshineasbefore</a></div>
              <br />
            </header>
            <article class="post-content">
              <p>spring data jpa 中文文档 1</p>

<h2 id="section">简介</h2>

<ul>
  <li>
    <p>为了让Spring Data的版本保持一致,可以使用maven提供的<code class="highlighter-rouge">dependencyManagement</code></p>

    <p>```xml</p>
    <dependencymanagement>
  <dependencies>
    <dependency>
      <groupid>org.springframework.data</groupid>
      <artifactid>spring-data-releasetrain</artifactid>
      <version>${release-train}</version>
      <scope>import</scope>
      <type>pom</type>
    </dependency>
  </dependencies>
</dependencymanagement>
    <p>```</p>
  </li>
  <li>
    <p>Spring Boot依赖管理</p>
  </li>
  <li>
    <p>Spring Boot 会选择一个较新的版本,但是假使你想升级到一个更新的版本,你可以只配置<code class="highlighter-rouge">spring-data-releasetrain.version</code>属性为下列属性值中的一个.</p>

    <blockquote>
      <p><code class="highlighter-rouge">BUILD-SNAPSHOT - current snapshots</code>
<code class="highlighter-rouge">M1, M2 etc. - milestones</code>
<code class="highlighter-rouge">RC1, RC2 etc. - release candidates</code>
<code class="highlighter-rouge">RELEASE - GA release</code>
<code class="highlighter-rouge">SR1, SR2 etc. - service releases</code></p>
    </blockquote>
  </li>
</ul>

<h2 id="spring-data-repositories">开始使用<code class="highlighter-rouge">Spring Data Repositories</code>.</h2>

<ul>
  <li>
    <p>核心概念 核心接口是<code class="highlighter-rouge">Repository</code>.它以<code class="highlighter-rouge">domain</code>和<code class="highlighter-rouge">domain的id类型</code>作为参数进行管理 . <code class="highlighter-rouge">CrudRepository</code> 接口提供了CRUD功能.</p>

    <p>```java
public interface Repository&lt;T, ID extends Serializable&gt; {</p>

    <p>}</p>

    <p>public interface CrudRepository&lt;T, ID extends Serializable&gt;
  extends Repository&lt;T, ID&gt; {</p>

    <s extends="" t=""> S save(S entity);

  T findOne(ID primaryKey);

  Iterable<t> findAll();

  Long count();

  void delete(T entity);

  boolean exists(ID primaryKey);

  // … more functionality omitted.
}
```

Spring Data  也提供持久化的具体抽象接口 比如说`JpaRepository` 和`MongoRepository` 这些接口扩展`CrudRepository` 并暴露出底层的持久化技术,但是`CrudRepository`等类似的比较通用的持久性与具体技术无关(没有直接的实现)的接口并不包含在内.其只提供要实现的方法.

接着`CrudRepository`有一个`PagingAndSortingRepository`的抽象接口.其有一些分页相关的功能.

```java
public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;
  extends CrudRepository&lt;T, ID&gt; {

  Iterable<t> findAll(Sort sort);

  Page<t> findAll(Pageable pageable);
}
```

获取一个每页20条第二页的`User` 信息,你可以只是简单的如此做:

```java
PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page<user> users = repository.findAll(new PageRequest(1, 20));
```

除查询的方法,查询数量和删除的语句也可以用这样的方式实现.

```java
public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  Long countByLastname(String lastname);
}
```

```java
public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  Long deleteByLastname(String lastname);

  List<user> removeByLastname(String lastname);

}
```

</user></user></t></t></t></s>
  </li>
  <li>
    <p>查询方法(Query Methods)</p>

    <ul>
      <li>标准的CRUD功能仓库实现的查询比较底层.用Spring Data,定义这些查询变成了四步:
        <ul>
          <li>
            <p>定义一实现了<code class="highlighter-rouge">Repository</code>接口或者它的子接口的接口,并且它将会绑定输入<code class="highlighter-rouge">domain类</code>和<code class="highlighter-rouge">domain类的ID类型</code>.</p>

            <p><code class="highlighter-rouge">java
interface PersonRepository extends Repository&lt;Person, Long&gt; {
    List&lt;Person&gt; findByLastname(String lastname);
}
</code></p>
          </li>
          <li>
            <p>定义查询的方法</p>

            <p><code class="highlighter-rouge">java
interface PersonRepository extends Repository&lt;Person, Long&gt; {
  List&lt;Person&gt; findByLastname(String lastname);
}
</code></p>
          </li>
          <li>
            <p>让<code class="highlighter-rouge">spring</code>为这些接口创建代理实例</p>

            <p>```java
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;</p>

            <p>@EnableJpaRepositories
class Config {}
```</p>
          </li>
          <li>
            <p>获得<code class="highlighter-rouge">repository</code>实例并且使用</p>

            <p>```java
public class SomeClient {</p>

            <p>@Autowired
  private PersonRepository repository;</p>

            <p>public void doSomething() {
    List<person> persons = repository.findByLastname("Matthews");
  }
}
```</person></p>
          </li>
        </ul>

        <p>接下来详细解释每一步:</p>
      </li>
      <li>
        <p>定义repository接口
第一部中你定义一个特定<code class="highlighter-rouge">domain</code>类型的repository接口.这个接口你必须继承<code class="highlighter-rouge">Repository</code>接口并且定义<code class="highlighter-rouge">domain类</code>和<code class="highlighter-rouge">ID类型</code>.如果你想暴露CRUD方法,你可以继承<code class="highlighter-rouge">CrudRepository</code>.</p>

        <ul>
          <li>
            <p>让Repository定义的更有规则
通常,你的repository接口会继承<code class="highlighter-rouge">Repository</code>,<code class="highlighter-rouge">CrudRepository</code>或者<code class="highlighter-rouge">PagingAndSortingRepository</code>.如果你不想继承<code class="highlighter-rouge">Spring Data interfaces</code> 你也可以用<code class="highlighter-rouge">@RepositoryDefinition</code>自己定义repository接口.继承<code class="highlighter-rouge">CrudRepository</code> 暴露了完整的管理你的实体的方法,如果你更喜欢自己定义哪些方法需要去暴露,只需要把要暴露的方法从<code class="highlighter-rouge">CrudRepository</code>中复制出来就可以了.</p>

            <p>```java
@NoRepositoryBean
interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {</p>

            <p>T findOne(ID id);</p>

            <p>T save(T entity);
}</p>

            <p>interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {
  User findByEmailAddress(EmailAddress emailAddress);
}
```</p>

            <p><strong>你需要确保你自己定义的repository接口有@NoRepositoryBean注解.这样可以保证Spring Data可以实例化它</strong></p>
          </li>
          <li>
            <p>利用<code class="highlighter-rouge">multiple Spring Data modules</code>来使用<code class="highlighter-rouge">Repositories</code>
使用应用程序中的一个独特的<code class="highlighter-rouge">Spring Data Module</code> 让事情变得很简单.因此在定义范围内的所有repository接口都会绑定到 <code class="highlighter-rouge">Spring Data Module</code> .有时候,应用程序需要多个<code class="highlighter-rouge">Spring Data Module</code>,这种情况下,它需要用持久化技术来区分不同的repository.<code class="highlighter-rouge">Spring Data Module</code>进入<code class="highlighter-rouge">strict repository mode</code> ,因为它检测到在类路径上有多个资源库的工厂.<code class="highlighter-rouge">strict repository mode</code>要求在repository或者domain的细节来决定一个<code class="highlighter-rouge">repository</code>定义的<code class="highlighter-rouge">Spring Data module</code>绑定:</p>

            <ul>
              <li>如果<code class="highlighter-rouge">repository</code>定义 继承<code class="highlighter-rouge">the module-specific repository</code></li>
              <li>
                <p>如果domain被<code class="highlighter-rouge">the module-specific type annotation</code>注解.例如JPA’s <code class="highlighter-rouge">@Entity</code>,或者说Spring Data MongoDb/Spring Data Elasticsearch的<code class="highlighter-rouge">@Document</code>.</p>

                <p>```java
interface MyRepository extends JpaRepository&lt;User, Long&gt; { }</p>

                <p>@NoRepositoryBean
interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends JpaRepository&lt;T, ID&gt; {
  …
}</p>

                <p>interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {
  …
}</p>

                <p>```
  MyRepository 和UserRepository 继承了JpaRepository 在他们的类型结构中,这是有效的.</p>

                <p>```java
interface AmbiguousRepository extends Repository&lt;User, Long&gt; {
…
}</p>

                <p>@NoRepositoryBean
interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; {
  …
}</p>

                <p>interface AmbiguousUserRepository extends MyBaseRepository&lt;User, Long&gt; {
  …
}
```
AmbiguousRepository 和AmbiguousUserRepository 分别继承Repository 和CrudRepository在他们的类型结构中,虽然这也是非常好的,<code class="highlighter-rouge">multiple modules </code>不能区分哪一个特定的<code class="highlighter-rouge">Spring Data</code>是repositories要绑定的.</p>

                <p>```java
interface PersonRepository extends Repository&lt;Person, Long&gt; {
 …
}</p>

                <p>@Entity
public class Person {
  …
}</p>

                <p>interface UserRepository extends Repository&lt;User, Long&gt; {
 …
}</p>

                <p>@Document
public class User {
  …
}
```
domain类被第三方(如@Entity或者@Document)注解注解了的.</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>定义查询方法</p>
  </li>
</ul>

<p>SpringData通过方法名有两种方式去解析出用户的查询意图:一种是直接通过方法的命名规则去解析,第二种是通过Query去解析,那么当同时存在几种方式时,SpringData怎么去选择这两
种方式呢?好了,SpringData有一个策略去决定到底使用哪种方式:</p>

<ul>
  <li>查询策略
接下来我们将介绍策略的信息,你可以通过配置<code class="highlighter-rouge">&lt;repository&gt;</code>的<code class="highlighter-rouge">query-lookup-strategy</code>属性来决定。或者通过Java config的<code class="highlighter-rouge"> Enable${store}Repositories</code>注解的<code class="highlighter-rouge">queryLookupStrategy</code>属性来指定:
    <ul>
      <li>CREATE 通过解析方法名字来创建查询。这个策略是删除方法中固定的前缀,然后再来解析其余的部分。</li>
      <li>USE_DECLARED_QUERY 它会根据已经定义好的语句去查询,如果找不到,则会抛出异常信息。这个语句可以在某个注解或者方法上定义。根据给定的规范来查找可用选项,如果在方法被调用时没有找到定义的查
询,那么会抛出异常。</li>
      <li>CREATE_IF_NOT_FOUND 这个策略结合了以上两个策略。他会优先查询是否有定义好的查询语句,如果没有,就根据方法的名字去构建查询。这是一个默认策略,如果不特别指定其他策略,那么这个策略会在项目
中沿用。</li>
    </ul>
  </li>
  <li>
    <p>构建查询
查询构造器是内置在SpringData中的,他是非常强大的,这个构造器会从方法名中剔除掉类似find…By, read…By, 或者get…By的前缀,然后开始解析其余的名字。你可以在方法名中加入更多的表达式,例如你需要Distinct的约束,那么你可以在方法名中加入Distinct即可。在方法中,第一个By表示着查询语句的开始,你也可以用And或者Or来关联多个条件。</p>

    <p><code class="highlighter-rouge">java
public interface PersonRepository extends Repository&lt;User, Long&gt; {
List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);
// 需要在语句中使用Distinct 关键字,你需要做的是如下
List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);
// 如果你需要忽略大小写,那么你要用IgnoreCase 关键字,你需要做的是如下
List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
// 所有属性都忽略大小写呢?AllIgnoreCase 可以帮到您
List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);
// 同样的,如果需要排序的话,那你需要:OrderBy
List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}
</code>
  根据方法名解析的查询结果跟数据库是相关,但是,还有几个问题需要注意:
  多个属性的查询可以通过连接操作来完成,例如<code class="highlighter-rouge">And,Or</code>。当然还有其他的,例如<code class="highlighter-rouge">Between,LessThan,GreaterThan,Like</code>。这些操作时跟数据库相关的,当然你还需要看看相关的数据库文档是否支持这些操作。
  你可以使用<code class="highlighter-rouge">IngoreCase</code>来忽略被标记的属性的大小写,也可以使用<code class="highlighter-rouge">AllIgnoreCase</code>来忽略全部的属性,当然这个也是需要数据库支持才允许的。
  你可以使用<code class="highlighter-rouge">OrderBy</code>来进行排序查询,排序的方向是Asc跟Desc,如果需要动态排序,请看后面的章节。</p>
  </li>
  <li>
    <p>属性表达式
具体的方法名解析查询需要怎样的规则呢?这种方法名查询只能用在被管理的实体类上,就好像之前的案例。假设一个类<code class="highlighter-rouge">Person</code>中有个<code class="highlighter-rouge">Address</code>,并且<code class="highlighter-rouge">Address</code>还有<code class="highlighter-rouge">ZipCode</code>,那么根据ZipCode来查询这个<code class="highlighter-rouge">Person</code>需要怎么做呢?</p>

    <p><code class="highlighter-rouge">java
List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);
</code></p>

    <p>在上面的例子中,我们用<code class="highlighter-rouge">x.address.zipCode</code>去检索属性,这种解析算法会在方法名中先找出实体属性的完整部分(<code class="highlighter-rouge">AddressZipCode</code>),检查这部分是不是实体类的属性,如果解析成功,则按
照驼峰式从右到左去解析属性,如:<code class="highlighter-rouge">AddressZipCode</code>将分为<code class="highlighter-rouge">AddressZip</code>跟<code class="highlighter-rouge">Code</code>,在这个时候,我们的属性解析不出Code属性,则会在此用同样的方式切割,分为<code class="highlighter-rouge">Address</code>跟<code class="highlighter-rouge">ZipCode</code>(如果
第一次分割不能匹配,解析器会向左移动分割点),并继续解析。
为了避免这种解析的问题,你可以用<code class="highlighter-rouge">“_”</code>去区分,如下所示:</p>

    <p><code class="highlighter-rouge">java
List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
</code></p>
  </li>
  <li>
    <p>特殊参数处理
上面的例子已经展示了绑定简单的参数,那么除此之外,我们还可以绑定一些指定的参数,如<code class="highlighter-rouge">Pageable</code>和<code class="highlighter-rouge">Sort</code>来动态的添加分页、排序查询。</p>

    <p><code class="highlighter-rouge">java
Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
List&lt;User&gt; findByLastname(String lastname, Sort sort);
List&lt;User&gt; findByLastname(String lastname, Pageable pageable);
</code></p>

    <p>第一个方法通过传递<code class="highlighter-rouge">org.springframework.data.domain.Pageable</code>来实现分页功能,排序也绑定在里面。如果需要排序功能,那么需要添加参数<code class="highlighter-rouge">org.springframework.data.domain.Sort</code>,如第二行中,返回的对象可以是<code class="highlighter-rouge">List</code>,当然也可以是<code class="highlighter-rouge">Page</code>类型的。</p>
  </li>
  <li>
    <p>限制查询结果
查询结果可以通过<code class="highlighter-rouge">first</code>或者<code class="highlighter-rouge">top</code>来进行限制,<code class="highlighter-rouge">first</code>或者<code class="highlighter-rouge">top</code>是可以替换的.可以用一个数字追加在<code class="highlighter-rouge">top/first</code>后边以指定返回结果的条数.如果这个数字在<code class="highlighter-rouge">first/top</code>左边,则返回结果大小为<code class="highlighter-rouge">1</code>.</p>

    <p>```java
User findFirstByOrderByLastnameAsc();</p>

    <p>User findTopByOrderByAgeDesc();</p>

    <p>Page<user> queryFirst10ByLastname(String lastname, Pageable pageable);</user></p>

    <p>Slice<user> findTop3ByLastname(String lastname, Pageable pageable);</user></p>

    <p>List<user> findFirst10ByLastname(String lastname, Sort sort);</user></p>

    <p>List<user> findTop10ByLastname(String lastname, Pageable pageable);
```</user></p>

    <p>表达的限制条件也可以使用<code class="highlighter-rouge">Distinct</code>关键字</p>
  </li>
  <li>
    <p>将查询结果放入到<code class="highlighter-rouge">Stream</code>中
查询结果可以用Java 8 <code class="highlighter-rouge">Stream&lt;T&gt;</code> 作为返回结果类型进行处理.</p>

    <p>```java
@Query(“select u from User u”)
Stream<user> findAllByCustomQueryAndStream();</user></p>

    <p>Stream<user> readAllByFirstnameNotNull();</user></p>

    <p>@Query(“select u from User u”)
Stream<user> streamAllPaged(Pageable pageable);
```</user></p>

    <p>但并不是所有的 Spring Data modules都能正确的支持<code class="highlighter-rouge">Stream&lt;T&gt;</code>作为返回结果类型.</p>
  </li>
  <li>
    <p>异步查询结果
Repository查询可以通过Spring的异步处理方法 异步执行.这意味着查询方法会立即返回.真是的查询会被作为一个task放入到<code class="highlighter-rouge">Spring TaskExecutor</code>中.</p>

    <p>```java
@Async
Future<user> findByFirstname(String firstname);</user></p>

    <p>@Async
CompletableFuture<user> findOneByFirstname(String firstname);</user></p>

    <p>@Async
ListenableFuture<user> findOneByLastname(String lastname);
Use java.util.concurrent.Future as return type.
Use a Java 8 java.util.concurrent.CompletableFuture as return type.
Use a org.springframework.util.concurrent.ListenableFuture as return type.
```</user></p>
  </li>
  <li>创建Repository实体
创建已定义的Repository接口,最简单的方式就是使用Spring配置文件,当然,需要JPA的命名空间。</li>
  <li>
    <p>XML配置
你可以使用JPA命名空间里面的repositories去自动检索路径下的repositories元素:</p>

    <p>```xml
<?xml version="1.0" encoding="UTF-8"?></p>
    <beans:beans xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/data/jpa" xsi:schemalocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

  <repositories base-package="com.acme.repositories" />

</beans:beans>
    <p>```
在本例中,Spring能够通过<code class="highlighter-rouge">base-package</code>检测出指定路径下所有继承Repository或者其子接口的接口(有点绕口)。每找到一个接口的时候,<code class="highlighter-rouge">FactoryBean</code>就会创建一个合适的代理去处理以及调用里面的查询方法。每个注册的Bean的名称都是源于接口名称,例如:UserRepository将会被注册为userRepository。<code class="highlighter-rouge">base-package</code>允许使用通配符作为扫描格式。</p>

    <ul>
      <li>
        <p>使用过滤器
在默认的设置中,将使用全路径扫描的方式去检索接口,当然,你在业务上可能需要更细致的操作,这时候,你可以在<code class="highlighter-rouge">&lt;repositories&gt;</code>中使用<code class="highlighter-rouge">&lt;include-filter&gt;</code>或者<code class="highlighter-rouge">&lt;exclude-filter&gt;</code>。这样的话,
你可以指定扫描的路径包含或者不包含指定的路径。</p>

        <p>```xml</p>
        <repositories base-package="com.acme.repositories">
  <context:exclude-filter type="regex" expression=".*SomeRepository" />
</repositories>
        <p>```
这个例子中,我们排除了所有以<code class="highlighter-rouge">SomeRepository</code>结尾的接口。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>JavaConfig
可以通过在一个JavaConfig 类上用<code class="highlighter-rouge">@Enable${store}Repositories</code>注解来触发.</p>

    <p>```java
@Configuration
@EnableJpaRepositories(“com.acme.repositories”)
class ApplicationConfiguration {</p>

    <p>@Bean
  public EntityManagerFactory entityManagerFactory() {
    // …
  }
}
```</p>
  </li>
  <li>
    <p>独立使用
你可以不在Spring容器里面使用repository。但是你还需要Spring的依赖包在你的<code class="highlighter-rouge">classpath</code>中,你需要使用<code class="highlighter-rouge">RepositoryFactory</code>来实现,代码如下:</p>

    <p><code class="highlighter-rouge">java
RepositoryFactorySupport factory = ... // 初始化
UserRepository repository = factory.getRepository(UserRepository. class);
</code></p>
  </li>
  <li>自定义Repository实现
  我们可以自己实现repository的方法。</li>
  <li>在repository中添加自定义方法
    <ul>
      <li>自定义接口:</li>
    </ul>

    <p><code class="highlighter-rouge">java
interface UserRepositoryCustom {
  public void someCustomMethod(User user);
}
</code>
* 自定义接口的实现类</p>

    <p>```java
class UserRepositoryImpl implements UserRepositoryCustom {</p>

    <p>public void someCustomMethod(User user) {
    // Your custom implementation
  }
}
```
* 扩展CRUDRepository</p>

    <p><code class="highlighter-rouge">java
interface UserRepository extends CrudRepository&lt;User, Long&gt;, UserRepositoryCustom {
  // Declare query methods here
}
</code>
  这样的话,就能够在常用的Repository中实现自己的方法。</p>
  </li>
  <li>
    <p>配置
在XML的配置里面,框架会自动搜索base-package里面的实现类,这些实现类的后缀必须满足repository-impl-postfix中指定的命名规则,默认的规则是:Impl</p>

    <p>```xml</p>
    <repositories base-="" package="com.acme.repository" />

    <repositories base-="" package="com.acme.repository" repository-impl-postfix="FooBar" />

    <p>```
第一个配置我们将找到com.acme.repository.UserRepositoryImpl,而第二个配置我们将找到com.acme.repository.UserRepositoryFooBar。</p>
  </li>
  <li>
    <p>人工装配
前面的代码中,我们使用了注释以及配置去自动装载。如果你自己定义的实现类需要特殊的装载,那么你可以跟普通bean一样声明出来就可以了,框架会手工的装载起来,而不是创建本身。</p>

    <p>```xml</p>
    <repositories base-package="com.acme.repository" />

    <beans:bean id="userRepositoryImpl" class="…">
</beans:bean>
    <p>```</p>
  </li>
  <li>
    <p>为所有的repository添加自定义方法
假如你要为所有的repository添加一个方法,那么前面的方法都不可行。你可以这样做:
1.你需要先声明一个中间接口,然后让你的接口来继承这个中间接口而不是Repository接口,代码如下:
中间接口:</p>

    <p>```java
@NoRepositoryBean
public interface MyRepository&lt;T, ID extends Serializable&gt;
  extends PagingAndSortingRepository&lt;T, ID&gt; {</p>

    <p>void sharedCustomMethod(ID id);
}
```
2.这时候,我们需要创建我们的实现类,这个实现类是基于Repository中的基类的,这个类会作为Repository代理的自定义类来执行。</p>

    <p>```java
public class MyRepositoryImpl&lt;T, ID extends Serializable&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; {</p>

    <p>private final EntityManager entityManager;</p>

    <p>public MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    super(entityInformation, entityManager);</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>// Keep the EntityManager around to used from the newly introduced methods.
this.entityManager = entityManager;   }
</code></pre>
    </div>

    <p>public void sharedCustomMethod(ID id) {
    // implementation goes here
  }
}
```</p>

    <p>3.配置自定义Repository的<code class="highlighter-rouge">base class</code></p>

    <ul>
      <li>
        <p>用JavaConfig类</p>

        <p><code class="highlighter-rouge">java
@Configuration
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration { … }
</code></p>
      </li>
      <li>
        <p>用XML</p>

        <p>```xml</p>
        <repositories base-package="com.acme.repository" repository-base-class="….MyRepositoryImpl" />

        <p>```</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Spring Data 扩展
这部分我们将会把SpringData扩展到其他框架中,目前我们继承的目标是SpringMVC。</p>
  </li>
  <li>
    <p>Querydsl扩展</p>

    <p>```java
public interface QueryDslPredicateExecutor<t> {</t></p>

    <div class="highlighter-rouge"><pre class="highlight"><code>T findOne(Predicate predicate);

Iterable&lt;T&gt; findAll(Predicate predicate);

long count(Predicate predicate);

boolean exists(Predicate predicate);

// … more functionality omitted. } ```
</code></pre>
    </div>

    <blockquote>
      <p>Finds and returns a single entity matching the <code class="highlighter-rouge">Predicate</code>.
Finds and returns all entities matching the <code class="highlighter-rouge">Predicate</code>.
Returns the number of entities matching the <code class="highlighter-rouge">Predicate</code>.
Returns if an entity that matches the <code class="highlighter-rouge">Predicate</code> exists.</p>
    </blockquote>

    <blockquote>
      <p><a href="http://www.iteye.com/topic/1132035"><code class="highlighter-rouge">Predicate</code>简介</a></p>
    </blockquote>
  </li>
  <li>
    <p>利用<code class="highlighter-rouge">Querydsl</code>,在你的Repository接口上继承<code class="highlighter-rouge">QueryDslPredicateExecutor</code></p>

    <p><code class="highlighter-rouge">java
interface UserRepository extends CrudRepository&lt;User, Long&gt;, QueryDslPredicateExecutor&lt;User&gt; {}
</code></p>
  </li>
  <li>
    <p>然后可以用Querydsl <code class="highlighter-rouge">Predicate</code>写类型安全的查询</p>

    <p><code class="highlighter-rouge">java
Predicate predicate = user.firstname.equalsIgnoreCase("dave")
.and(user.lastname.startsWithIgnoreCase("mathews"));
userRepository.findAll(predicate);
</code></p>
  </li>
  <li>
    <p>Web支持
SpringData支持很多web功能。当然你的应用也要有SpringMVC的Jar包,有的还需要继承Spring HATEOAS。
通常来说,你可以在你的JavaConfig配置类中加入@EnableSpringDataWebSupport即可:</p>

    <p><code class="highlighter-rouge">java
  @Configuration
  @EnableWebMvc
  @EnableSpringDataWebSupport
  class WebConfiguration { }
</code></p>

    <p>这个注解注册了几个功能,我们稍后会说,他也能检测Spring HATEOAS,并且注册他们。
如果你用XML配置的话,那么你可以用下面的配置:
在xml中配置:</p>

    <p>```xml</p>
    <bean class="org.springframework.data.web.config.SpringDataWebConfiguration" />

    <p><!-- If you're using Spring HATEOAS as well register this one *instead* of the former --></p>
    <bean class="org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration" />

    <p>```</p>

    <ul>
      <li>基本的web支持
上面的配置注册了以下的几个功能:
        <ol>
          <li>DomainClassConverter将会让SpringMVC能从请求参数或者路径参数中解析出来。</li>
          <li>HandlerMethodArgumentResolver 能让SpringMVC从请求参数中解析出Pageable(分页)与Sort(排序)。</li>
        </ol>
      </li>
      <li>
        <p>DomainClassConverter
这个类允许你在SpringMVC控制层的方法中直接使用你的领域类型(Domain types),如下:</p>

        <p>```java
@Controller
@RequestMapping(“/users”)
public class UserController {</p>

        <p>@RequestMapping(“/{id}”)
  public String showUserForm(@PathVariable(“id”) User user, Model model) {</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>model.addAttribute("user", user);
return "userForm";   } } ``` 正如你所见,上面的方法直接接收了一个User对象,你不需要做任何的搜索操作,这个转换器自动的设id的值进去对象中,并且最终调用了`findOne`方法查询出实体。`(注:当前的Repository 必须实现CrudRepository)`
</code></pre>
        </div>
      </li>
      <li>
        <p>HandlerMethodArgumentResolver分页排序
这个配置项同时注册了PageableHandlerMethodArgumentResolver 和 SortHandlerMethodArgumentResolver,使得Pageable跟Sort能作为控制层的参数使用:</p>

        <p>```java
@Controller
@RequestMapping(“/users”)
public class UserController {</p>

        <p>@Autowired UserRepository repository;</p>

        <p>@RequestMapping
  public String showUsers(Model model, Pageable pageable) {</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>model.addAttribute("users", repository.findAll(pageable));
return "users";   } } ```
</code></pre>
        </div>

        <p>这个配置会让SpringMVC传递一个Pageable实体参数,下面是默认的参数:</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">参数名</th>
              <th style="text-align: left">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">page</td>
              <td style="text-align: left">你要获取的页数</td>
            </tr>
            <tr>
              <td style="text-align: left">size</td>
              <td style="text-align: left">一页中最大的数据量</td>
            </tr>
            <tr>
              <td style="text-align: left">sort</td>
              <td style="text-align: left">需要被排序的属性(格式:属性1,属性2(ASC/DESC)),默认是ASC,使用多个字段排序,你可以使用sort=first&amp;sort=last,asc</td>
            </tr>
          </tbody>
        </table>

        <p>如果你需要对多个表写多个分页或排序,那么你需要用@Qualifier来区分,请求参数的前缀是${qualifire}_,那么你的方法可能变成这样:</p>

        <p><code class="highlighter-rouge">java
public String showUsers(Model model,
    @Qualifier("foo") Pageable first,
    @Qualifier("bar") Pageable second) { … }
</code></p>

        <p>你需要填写foo_page和bar_page等。
 默认的Pageable相当于new PageRequest(0,20),你可以用@PageableDefaults注解来放在Pageable上。</p>
      </li>
      <li>
        <p>超媒体分页
Spring HATEOAS有一个PagedResources类,他丰富了Page实体以及一些让用户更容易导航到资源的请求方式。Page转换到PagedResources是由一个实现了Spring HATEOAS
ResourceAssembler接口的实现类:PagedResourcesAssembler提供转换的。</p>

        <p><code class="highlighter-rouge">java
@Controller
class PersonController {
  @Autowired PersonRepository repository;
  @RequestMapping(value = "/persons", method = RequestMethod.GET)
  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,
    PagedResourcesAssembler assembler) {
    Page&lt;Person&gt; persons = repository.findAll(pageable);
    return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);
  }
}
</code></p>

        <p>上面的toResources方法会执行以下的几个步骤:</p>

        <ol>
          <li>Page对象的内容会转换成为PagedResources对象。</li>
          <li>PagedResources会的到一个PageMetadata的实体附加,包含Page跟PageRequest。</li>
          <li>PagedResources会根据状态得到prev跟next链接,这些链接指向URI所匹配的方法中。分页参数会根据PageableHandlerMethodArgumentResolver配置,以让其在后面的方法中</li>
          <li>解析使用。
假使我们现在有30个Person实例在数据库中,你可以通过<code class="highlighter-rouge">GET</code> http://localhost:8080/persons 并且 你会得到像下边这样的一些反馈:</li>
        </ol>

        <p><code class="highlighter-rouge">json
{ "links" : [ { "rel" : "next",
            "href" : "http://localhost:8080/persons?page=1&amp;size=20 }
  ],
  "content" : [
     … // 20 Person instances rendered here
  ],
  "pageMetadata" : {
    "size" : 20,
    "totalElements" : 30,
    "totalPages" : 2,
    "number" : 0
  }
}
</code></p>
      </li>
      <li>
        <p>Querydsl web支持
它可以从<code class="highlighter-rouge">Request</code>的query string中提取出一些属性,并转换成Querydsl样式.
这意味着它可以把</p>

        <p><code class="highlighter-rouge">http
?firstname=Dave&amp;lastname=Matthews
</code>
这样的query string 解析成:</p>

        <p><code class="highlighter-rouge">java
QUser.user.firstname.eq("Dave").and(QUser.user.lastname.eq("Matthews"))
</code></p>
      </li>
      <li>
        <p>使用<code class="highlighter-rouge">QuerydslPredicateArgumentResolver</code>.</p>

        <p><em>在未来当Querydsl在classpath中被发现时,仅仅使用<code class="highlighter-rouge">@EnableSpringDataWebSupport</code>就可以激活</em>
在方法上增加一个<code class="highlighter-rouge">@QuerydslPredicate</code>将会提供一个可以通过<code class="highlighter-rouge">QueryDslPredicateExecutor</code>来执行的<code class="highlighter-rouge">Predicate</code>
<em>使用<code class="highlighter-rouge">QueryDslPredicateExecutor</code>中的<code class="highlighter-rouge">root</code>属性来确定<code class="highlighter-rouge">@QuerydslPredicate</code>的返回值类型</em></p>

        <p>```java
@Controller
class UserController {</p>

        <p>@Autowired UserRepository repository;</p>

        <p>@RequestMapping(value = “/”, method = RequestMethod.GET)
  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,
          Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) {</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>model.addAttribute("users", repository.findAll(predicate, pageable));

return "index";   } } ```
</code></pre>
        </div>

        <p>为User解析query string来匹配<code class="highlighter-rouge">Predicate</code>
默认的绑定方式如下:</p>

        <p>1.<code class="highlighter-rouge">Object</code> on simple properties as <code class="highlighter-rouge">eq</code>.
2.<code class="highlighter-rouge">Object</code> on collection like properties as <code class="highlighter-rouge">contains</code>.
3.<code class="highlighter-rouge">Collection</code> on simple properties as <code class="highlighter-rouge">in</code>.
这样的绑定可以通过<code class="highlighter-rouge">@QuerydslPredicate</code>的<code class="highlighter-rouge">bingdings</code>属性来定制,也可以使用Java 8 的<code class="highlighter-rouge">default methods</code> 在Repository接口上追加<code class="highlighter-rouge">QuerydslBinderCustomizer</code></p>

        <p><code class="highlighter-rouge">java
interface UserRepository extends CrudRepository&lt;User, String&gt;,
                              QueryDslPredicateExecutor&lt;User&gt;,
                              QuerydslBinderCustomizer&lt;QUser&gt; {
  @Override
  default public void customize(QuerydslBindings bindings, QUser user) {
    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))
    bindings.bind(String.class)
      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value));
    bindings.excluding(user.password);
  }
}
</code></p>

        <ul>
          <li><code class="highlighter-rouge">QueryDslPredicateExecutor</code> 给<code class="highlighter-rouge">Predicate</code> 提供具体的查找方法.</li>
          <li>在Repository 接口中<code class="highlighter-rouge">QuerydslBinderCustomizer</code> 的定义和<code class="highlighter-rouge">@QuerydslPredicate(bindings=…​)</code>的快捷方式将会被自动抓取</li>
          <li><code class="highlighter-rouge">username</code> 属性的绑定就是一个简单的<code class="highlighter-rouge">contains</code>绑定.</li>
          <li>默认的<code class="highlighter-rouge">String</code>属性绑定是不区分大小写的匹配<code class="highlighter-rouge">contains</code></li>
          <li>Exclude the password property from Predicate resolution.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Repository填充
如果你用过Spring JDBC,那么你肯定很熟悉使用SQL去填写数据源(DataSource),在这里,我们可以使用XML或者Json去填写数据,而不再使用SQL填充。
假如你有一个data.json的文件,如下:</p>

    <p><code class="highlighter-rouge">json
[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]
</code></p>

    <p>要PersonRepository填充这些数据进去,你需要做如下的声明:</p>

    <p>```xml
<?xml version="1.0" encoding="UTF-8"?></p>
    <beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:repository="http://www.springframework.org/schema/data/repository" xsi:schemalocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd">
<repository:jackson2-populator locations="classpath:data.json" />
</beans>
    <p>```
  这个声明使得data.json能够通过Jackson ObjectMapper被其他地方读取,反序列化。</p>
  </li>
  <li>
    <p>Legacy Web(传统web)支持</p>

    <ul>
      <li>
        <p>在SpringMVC中绑定领域类(Domain class)
你在开发web项目的时候,你经常需要从URL或者请求参数中解析领域类中的ID,你可能是这么做得:</p>

        <p>```java
@Controller
@RequestMapping(“/users”)
public class UserController {</p>

        <p>private final UserRepository userRepository;</p>

        <p>@Autowired
  public UserController(UserRepository userRepository) {
    Assert.notNull(repository, “Repository must not be null!”);
    this.userRepository = userRepository;
  }</p>

        <p>@RequestMapping(“/{id}”)
  public String showUserForm(@PathVariable(“id”) Long id, Model model) {</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>// Do null check for id
User user = userRepository.findOne(id);
// Do null check for user

model.addAttribute("user", user);
return "user";   } } ``` 首先你要注入一个UserRepository ,然后通过findOne查询出结果。幸运的是,Spring提供了自定义组件允许你从String类型到任意类型的转换。
</code></pre>
        </div>
      </li>
      <li>
        <p>PropertyEditors(属性编辑器)
在Spring3.0之前,Java的PropertyEditor已经被使用。现在我们要集成它,SpringData提供了一个DomainClassPropertyEditorRegistrar类,他能在ApplicationContext中查找SpringData的
Repositories,并且注册自定义的PropertyEditor。</p>

        <p>```xml</p>
        <bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter">
  <property name="webBindingInitializer">
    <bean class="….web.bind.support.ConfigurableWebBindingInitializer">
      <property name="propertyEditorRegistrars">
        <bean class="org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar" />
      </property>
    </bean>
  </property>
</bean>
        <p>```</p>

        <p>如果你做了上面的工作,那么你在前面的例子中,会大大减少工作量:</p>

        <p><code class="highlighter-rouge">java
  @Controller
  @RequestMapping("/users")
  public class UserController {
  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") User user, Model model) {
  model.addAttribute("user", user);
  return "userForm";
  }
  }
</code></p>
      </li>
    </ul>
  </li>
  <li>
    <p>转换服务
在Spring3以后,PropertyEditor已经被转换服务取代了,SpringData现在用DomainClassConverter模仿
  DomainClassPropertyEditorRegistrar中的实现。你可以使用如下的配置:</p>

    <p>```xml</p>
    <mvc:annotation-driven conversion-service="conversionService" />

    <bean class="org.springframework.data.repository.support.DomainClassConverter">
  <constructor-arg ref="conversionService" />
```

如果你是用JavaConfig,你可以集成SpringMVC的WebMvcConfigurationSupport并且处理FormatingConversionService,那么你可以这么做:

```java
public class WebConfiguration extends WebMvcConfigurationSupport {
  // 省略其他配置
  @Bean
  public DomainClassConverter&lt;?&gt; domainClassConverter() {
  return new DomainClassConverter<formattingconversionservice>(mvcConversionService());
  }
}
```
</formattingconversionservice></bean>
  </li>
</ul>

            </article>
        </div>
      </div>
      <div class="panel docs-content">
        <article class="post-content">
          <div class="wrapper">
            


  <div class="ds-thread" data-thread-key="/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(1)/" data-title="spring-data-jpa 中文文档(1)" data-url="http://www.veryjava.cn/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(1)/"></div>

<script type="text/javascript">
var duoshuoQuery = {short_name:"ssab"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


 
          </div>
        </article>
      </div>
    </div>
  </div>
</div>

    
    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2016 <a href=""><code>sunshineasbefore</code></a>.</p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, theme from <a href="http://lesscss.cn/">Less</a></p>
	</div>
</footer>

<script src="/styles/js/jquery.min.js"></script>
<script src="/styles/js/bootstrap.min.js"></script>
<script src="/styles/js/holder.min.js"></script>
<script src="/styles/js/application.js"></script>
<script src="/styles/js/lessismore.js"></script>

  </body>
</html>
