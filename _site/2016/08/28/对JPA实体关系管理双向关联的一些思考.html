<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>对JPA实体关系管理双向关联的一些思考</title>
  <meta name="description" content="  现象  在使用JPA进行实体关系管理的时候,会产生无限循环的情况,如果使用fastjson来进行序列化,则表现形式如下:">

  <link rel="canonical" href="http://veryjava.cn//2016/08/28/%E5%AF%B9JPA%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html">

  <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
  <!-- <link rel="stylesheet" href="/assets/css/icard_resume.css"> -->
  <link rel="stylesheet" href="/assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="/assets/css/blog.css" >
  <link rel="stylesheet" href="/assets/css/syntax.css">

  <link rel="icon" type="image/png" href="/assets/img/avatar.JPG">

  <!-- Google fonts -->
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:300' type='text/css'>
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Source+Sans+Pro' type='text/css'>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="assets/js/html5shiv.min.js"></script>
  <script src="assets/js/respond.min.js"></script>
  <![endif]-->

</head>

    <body>
        <header class="bloghead">
    <dev class="authorheader">
        <a href="/">
            <img alt="My Avatar" src="/assets/img/avatar.JPG"/>
        </a>
        <dev class="blogtitle">
            <h1><a href="/">Barton</a></h1>
            <h5> 怀揣梦想,永不止步! </h5>
        </dev>
    </dev>

    <nav class="menu" role="nav">
        <ul>
            <li><a href="/">主页</a></li>
            <li>|</li>
            <li><a href="/menu.html">文章列表</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://github.com/sunshineasbefore">Github</a></li>
            <li>|</li>
            <li><a target="_blank" href="/about.html"> 关于我 </a></li>
        </ul>
    </nav>
</header>


        <main class="blogmain">
            <header>
                <h1 class="article-title">对JPA实体关系管理双向关联的一些思考</h1>
                <p class="article-time">
                    2016年08月28日 星期六,  发表于 <span>济南</span>
                </p>
                <p class="article-hint">
                    如果你对本文有任何的建议或者疑问, 可以在
                    <a href="https://github.com/sunshineasbefore/blog/issues" target="_blank">这里给我提 Issues</a>, 谢谢! :)
                </p>
            </header>
            <ul>
  <li>
    <p>现象
  在使用JPA进行实体关系管理的时候,会产生无限循环的情况,如果使用fastjson来进行序列化,则表现形式如下:</p>

    <p><code class="highlighter-rouge"><span class="w">
  </span><span class="p">{</span><span class="w">
      </span><span class="nt">"address"</span><span class="p">:{</span><span class="w">
          </span><span class="nt">"id"</span><span class="p">:</span><span class="mi">63</span><span class="p">,</span><span class="w">
          </span><span class="nt">"name"</span><span class="p">:</span><span class="s2">"1address name"</span><span class="p">,</span><span class="w">
          </span><span class="nt">"person"</span><span class="p">:{</span><span class="nt">"$ref"</span><span class="p">:</span><span class="s2">".."</span><span class="p">},</span><span class="w">
          </span><span class="nt">"zipCode"</span><span class="p">:</span><span class="s2">"ZipCode01"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nt">"firstName"</span><span class="p">:</span><span class="s2">"0firstName"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"id"</span><span class="p">:</span><span class="mi">69</span><span class="p">,</span><span class="w">
      </span><span class="nt">"lastName"</span><span class="p">:</span><span class="s2">"0lastName"</span><span class="w">
  </span><span class="p">}</span><span class="err">,</span><span class="w">
  </span><span class="p">{</span><span class="w">
      </span><span class="nt">"address"</span><span class="p">:{</span><span class="w">
          </span><span class="nt">"id"</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span><span class="w">
          </span><span class="nt">"name"</span><span class="p">:</span><span class="s2">"2address name"</span><span class="p">,</span><span class="w">
          </span><span class="nt">"person"</span><span class="p">:{</span><span class="nt">"$ref"</span><span class="p">:</span><span class="s2">".."</span><span class="p">},</span><span class="w">
          </span><span class="nt">"zipCode"</span><span class="p">:</span><span class="s2">"ZipCode11"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nt">"firstName"</span><span class="p">:</span><span class="s2">"1firstName"</span><span class="p">,</span><span class="w">
      </span><span class="nt">"id"</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span><span class="w">
      </span><span class="nt">"lastName"</span><span class="p">:</span><span class="s2">"1lastName"</span><span class="w">
  </span><span class="p">}</span><span class="w">
 </span></code></p>

    <p><em>重点是<code class="highlighter-rouge">address.person</code>的值:<code class="highlighter-rouge"><span class="p">{</span><span class="nt">"$ref"</span><span class="p">:</span><span class="s2">".."</span><span class="p">}</span></code></em>
  如果你用的不是fastjson(它默认会检查该对象是否已经存在在json文本中)而是其他一些json类库,比如jackson,则会抛出<code class="highlighter-rouge">java.lang.StackOverflowError</code>异常(无限循环产生的栈溢出所导致).
  但是,哪怕你用的是fastjson,你也无法用js来解析<code class="highlighter-rouge"><span class="p">{</span><span class="nt">"$ref"</span><span class="p">:</span><span class="s2">".."</span><span class="p">}</span></code>.</p>
  </li>
  <li>解决思路
    <ul>
      <li>使用fastjson自带的<code class="highlighter-rouge">JSON.toJSONString(page,SerializerFeature.DisableCircularReferenceDetect)</code>
        <ul>
          <li>优点:解决快速</li>
          <li>缺点:
            <ul>
              <li>序列化后的json文本包含太多不需要的信息,冗杂程度太高</li>
              <li>方式太死板,没有相应的注解来实现(jackson有一个),接口只能返回String类型了.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>重新设计实体关系,<em>尽量避免双向关联</em>,使用RESTful进行接口的暴露.(举个例子来说)
        <ul>
          <li>优点:逻辑清晰,结构更合理</li>
          <li>缺点:
            <ul>
              <li>对老代码改动较大.</li>
              <li>实现较复杂,要对整体业务逻辑有清晰的认识.</li>
            </ul>
          </li>
        </ul>

        <p>实体类Person
  ```
  public class Person {
      private String name;</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  @Id
  @GeneratedValue
  private Long id;

  @ManyToMany
  @JoinColumn(name = "address_id")
  private List&lt;Address&gt; addresses;

  // ...... getter and setter   }   ```
</code></pre>
        </div>

        <p>实体类Address
  ```
  public class Address {
      @Id
      @GeneratedValue
      private Long id;</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>  private String name;

  private String zipCode;

  // ...... getter and setter   }   ```
</code></pre>
        </div>

        <p>两个实体类之间的关系为Many Person To Many Address,只在Person实体类中进行关系的配置,避免双向关联.</p>

        <p>下面举例说明使用RESTful来对资源进行访问的情况.</p>

        <p>对于Person:
  * 1 查询所有Person: <code class="highlighter-rouge">/persons</code>
  * 2 查询某一个Person: <code class="highlighter-rouge">/persons/{person_id}</code>
  * 3 <strong>查询某一个Person的所有Address: <code class="highlighter-rouge">/persons/{person_id}/addresses</code></strong>
  * 4 <strong>查询某一个Person的某一个Address: <code class="highlighter-rouge">/persons/{person_id}/addresses/{address_id}</code></strong></p>

        <p>如果要查询一个Address有几个Person:  <code class="highlighter-rouge">/persons?address.id=xxx</code> (带分页,自己设置pageSize)</p>

        <p>对于Address:
  * 1 查询所有Address: <code class="highlighter-rouge">/addresses</code>
  * 2 查询某一个Address: <code class="highlighter-rouge">/addresses/{address_id}</code></p>

        <p>以上是Person和Address的一些简单接口.其中<strong>粗体</strong>部分为关联查询.
  设计的思路就是要尽量避免双向关联,然后把Person作为一个资源,把Address作为Person的一个子资源或者属性.
  上述Person中的1 2 将Address作为了属性,查询时可以通过参数传递进去.而上述Person中的3 4 两个接口则将Address作为一个子资源进行管理.</p>

        <p>如果要用Address来作为一个资源反查Person怎么办?
  在一个Address管理页面,需求要求列出某一个住址下的Person:
  * 点击某一项:
          Address发起<code class="highlighter-rouge">/persons?address.id=xxx</code>请求,取得<code class="highlighter-rouge">List&lt;Person&gt;</code>.
  * 默认显示:
          在controller层对<code class="highlighter-rouge">/persons?address.id_in=xxx1,xxx2,xxx3</code>接口的返回值进行处理,取得<code class="highlighter-rouge">List&lt;Address&gt;</code>和其对应的<code class="highlighter-rouge">List&lt;Person&gt;</code></p>
      </li>
    </ul>
  </li>
  <li>总结
  尽量避免双向关联,使用更合理的API设计方式,合理区分子资源和属性.
  大大减少数据库压力!</li>
</ul>

            <footer class="article-footer">
    <div class="authorimage">
        <img src="/assets/img/avatar.JPG" alt="My Avatar" class="img-circle">
    </div>
    <section class="author">
        <h4><a href="/about.html">王</a></h4>
        <a href="mailto:work_wjj@163.com">work_wjj@163.com</a>
    </section>
</footer>

        </main>

        <div class="footer-copyright">
    <div class="container-fluid">
        <div class="row-fluid">
            <div class="col-md-12">
                Copyright &copy; 2016 王 - All rights reserved.
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="/assets/js/jquery.min.js"></script>
<script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74743250-2', 'auto');
  ga('send', 'pageview');

</script>


    </body>

</html>
