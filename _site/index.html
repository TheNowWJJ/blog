<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>阳光如初.</title>
  <meta name="description" content="sunshineasbefore.github.io/blog">

  <link rel="canonical" href="sunshineasbefore.github.io/blog/blog/">

  <link rel="stylesheet" href="/blog/assets/css/bootstrap.min.css">
  <!-- <link rel="stylesheet" href="/blog/assets/css/icard_resume.css"> -->
  <link rel="stylesheet" href="/blog/assets/css/font-awesome.min.css">
  <link rel="stylesheet" href="/blog/assets/css/blog.css" >
  <link rel="stylesheet" href="/blog/assets/css/syntax.css">

  <link rel="icon" type="image/png" href="/assets/img/avatar.JPG">

  <!-- Google fonts -->
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans:300' type='text/css'>
  <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Source+Sans+Pro' type='text/css'>

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
  <script src="assets/js/html5shiv.min.js"></script>
  <script src="assets/js/respond.min.js"></script>
  <![endif]-->

</head>


  <body>

    <header class="bloghead">
    <dev class="authorheader">
        <a href="/">
            <img alt="My Avatar" src="/assets/img/avatar.JPG"/>
        </a>
        <dev class="blogtitle">
            <h1><a href="/">Barton</a></h1>
            <h5> 怀揣梦想,永不止步! </h5>
        </dev>
    </dev>

    <nav class="menu" role="nav">
        <ul>
            <li><a href="/">主页</a></li>
            <li>|</li>
            <li><a href="/menu.html">文章列表</a></li>
            <li>|</li>
            <li><a target="_blank" href="https://github.com/sunshineasbefore">Github</a></li>
            <li>|</li>
            <li><a target="_blank" href="/about.html"> 关于我 </a></li>
        </ul>
    </nav>
</header>

    <main class="blogmain">
      
<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/%E5%AF%B9JPA%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html">  对JPA实体关系管理双向关联的一些思考 </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            

        </p>
        <p class="readmore">
            <a href="/2016/08/28/%E5%AF%B9JPA%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E7%AE%A1%E7%90%86%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83.html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/%E4%BD%BF%E7%94%A8-java-getter.setter%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AEapache-shiro.html">  基于java getter/setter方法配置apache shiro </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <ul>
  <li>说明
    <ul>
      <li>谷歌,百度上介绍apache shiro配置的文章并不少,但是缺少我想要的基于java getter/setter方法配置apache shiro的文章.今天整一个.</li>
      <li>重点在于 ShiroConfig类中如何配置shiroFilter,securityManager,tokenRealm,sessionListener以及sessionManager.</li>
      <li><em>@Configuration</em>是spring的一个注解,用来标识该类是一个配置类,并且会注入到spring容器中.可以直接使用@Autowird注入.</li>
    </ul>
  </li>
  <li>代码
  SessionListener:</li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/%E4%BD%BF%E7%94%A8-java-getter.setter%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AEapache-shiro.html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(2).html">  spring-data-jpa 中文文档(2) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>spring-data-jpa 中文文档(2)</strong></p>

<ul>
  <li><strong>JPA Repositories</strong>
    <ul>
      <li>简介
        <ul>
          <li>Spring命名空间
  SpringData使用了自定义的命名空间去定义repository。通常我们会使用repositories元素:</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(2).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(1).html">  spring-data-jpa 中文文档(1) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>spring-data-jpa 中文文档(1)</strong></p>

<ul>
  <li>简介</li>
  <li>为了让Spring Data的版本保持一致,可以使用maven提供的<code class="highlighter-rouge">dependencyManagement</code></li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/spring-data-jpa-%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3(1).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Spring-MVC-%E7%AE%80%E4%BB%8B.html">  Spring MVC 简介 </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Spring MVC 简介</strong></p>

<ul>
  <li>MVC概述
    <ul>
      <li>MVC 是 Model-View-Control 的简称，即模型-视图-控制器。它是一个存在于服务器表达层的模型，它将应用分开，改变应用之间的高度耦合。</li>
      <li>视图
        <ul>
          <li>数据的展现。视图是用户看到并与之交互的界面。视图向用户显示相关的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。视图可以向模型查询业务状态，但不能改变模型。视图还能接受模型发出的数据更新事件，从而对用户界面进行同步更新。</li>
        </ul>
      </li>
      <li>模型
        <ul>
          <li>应用对象。模型是应用程序的主体部分。 模型代表了业务数据和业务逻辑； 当数据发生改变时，它要负责通知视图部分；一个模型能为多个视图提供数据。由于同一个模型可以被多个视图重用，所以提高了应用的可重用性。</li>
        </ul>
      </li>
      <li>控制器
        <ul>
          <li>逻辑处理、控制实体数据在视图上展示、调用模型处理业务请求。当 Web 用户单击 Web 页面中的提交按钮来发送 HTML 表单时，控制器接收请求并调用相应的模型组件去处理请求，然后调用相应的视图来显示模型返回的数据。</li>
        </ul>
      </li>
      <li>MVC 模型运行机制
 在 MVC 模式中，Web 用户向服务器提交的所有请求都由控制器接管。接受到请求之后，控制器负责决定应该调用哪个模型来进行处理；然后模型根据用户请求进行相应的业务逻辑处理，并返回数据；最后控制器调用相应的视图来格式化模型返回的数据，并通过视图呈现给用户。</li>
    </ul>
  </li>
</ul>

<p><img src="http://dl.iteye.com/upload/attachment/576353/d3d769c0-5df9-3c31-9984-42f1fcbd00bb.jpg" alt="MVC 模型运行机制" /></p>

<ul>
  <li>三层架构概述
    <ul>
      <li>Presentation tier + Application tier + Data tier (展现层 + 应用层 + 数据访问层)</li>
      <li>实际上MVC只存在三层架构的展现层,M实际商是数据模型,是包含数据的对象.</li>
      <li>Service和Dao层反馈在应用层和数据访问层</li>
    </ul>
  </li>
  <li>Spring MVC 介绍
    <ul>
      <li>Spring Web MVC处理请求的流程
  具体执行步骤如下：
        <ul>
          <li>
            <p>首先用户发送请求—–&gt;前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图2-1中的1、2步骤；</p>
          </li>
          <li>
            <p>页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在Spring Web MVC中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；图2-1中的3、4、5步骤；</p>
          </li>
          <li>
            <p>前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图2-1中的步骤6、7；</p>
          </li>
          <li>
            <p>前端控制器再次收回控制权，将响应返回给用户，图2-1中的步骤8；至此整个结束
<img src="http://sishuok.com/forum/upload/2012/7/14/529024df9d2b0d1e62d8054a86d866c9__1.JPG" alt="Spring Web MVC处理请求的流程" /></p>
          </li>
        </ul>
      </li>
      <li>Spring MVC的优势</li>
      <li>
        <p>清晰的角色划分：前端控制器（DispatcherServlet）、请求到处理器映射（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）、处理器或页面控制器（Controller）、验证器（   Validator）、命令对象（Command  请求参数绑定到的对象就叫命令对象）、表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</p>
      </li>
      <li>
        <p>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要；</p>
      </li>
      <li>
        <p>由于命令对象就是一个POJO，无需继承框架特定API，可以使用命令对象直接作为业务对象；</p>
      </li>
      <li>
        <p>和Spring 其他框架无缝集成，是其它Web框架所不具备的；</p>
      </li>
      <li>
        <p>可适配，通过HandlerAdapter可以支持任意的类作为处理器；</p>
      </li>
      <li>
        <p>可定制性，HandlerMapping、ViewResolver等能够非常简单的定制；</p>
      </li>
      <li>
        <p>功能强大的数据验证、格式化、绑定机制；</p>
      </li>
      <li>
        <p>利用Spring提供的Mock对象能够非常简单的进行Web层单元测试；</p>
      </li>
      <li>
        <p>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</p>
      </li>
      <li>
        <p>强大的JSP标签库，使JSP编写更容易。</p>
      </li>
      <li>
        <p>………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。</p>
      </li>
      <li>Spring MVC的常用注解
        <ul>
          <li>@ Controller 表明这个类是Spring MVC里的Controller.Dispatcher Servlet 会自动扫描注解了此注解的类.在声明普通Bean的时候,使用@Component,@Service,@Repository和@Controller是等同的,因为@Service,@Repository,@Controller都组合了@Component元注解.但在Spring MVC声明控制器Bean的时候,只能使用@Controller.</li>
          <li>@RequestMapping 用来映射Web请求(访问路径和参数),处理类和方法.其支持Servlet的request和response作为参数.</li>
          <li>@ResponseBody 支持将返回值放在response体内,而不是返回一个页面,此注解可放置在返回值前或者方法上.</li>
          <li>@RequestBody 允许request的参数在request体中,而不是直接链接在地址后面.此注解放置在参数前.</li>
          <li>@PathVariable 用来接收路径参数,此注解放置在参数前.</li>
          <li>@RestController 这是一个组合注解,组合了@Controller和@ResponseBody</li>
          <li><strong>延伸阅读: <a href="http://blog.csdn.net/jcx5083761/article/details/9340209">什么是request,response</a></strong></li>
        </ul>
      </li>
      <li>Spring MVC 基本配置
  Spring MVC的定制配置需要我们的配置类集成一个WebMvcConfigurerAdapter类,并在此类使用@EnableWebMvc注解,来开启Spring MVC的配置支持.</li>
      <li>Spring MVC 静态资源配置
  <a href="http://blog.csdn.net/isea533/article/details/50412212">Spring Boot默认的静态资源配置</a>
  如果需要直接访问静态资源,可以在我们的配置类中重写 addResourceHandlers方法</li>
      <li>快捷的ViewController
  无需做任何业务处理,只是简单的页面转向,可以使用addViewControllers方法来实现.</li>
    </ul>
  </li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/Spring-MVC-%E7%AE%80%E4%BB%8B.html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Spring-Boot%E7%9A%84Web%E5%BC%80%E5%8F%91.html">  Spring Boot的Web开发 </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Spring Boot的Web开发</strong></p>

<ul>
  <li>Spring Boot的Web开发支持
  Spring Boot提供了spring-boot-starter-web为Web开发予以支持.它为我们提供了嵌入的Tomcat以及Spring MVC的依赖.</li>
  <li>Thymeleaf模板引擎
  Spring Boot 推荐使用Thymeleaf作为模板引擎.因为其提供了完整的Spring MVC支持.
  因为使用嵌入的Servlet容器来运行JSP的话有一些小问题,内嵌Tomcat,Jetty不支持以jar的形式运行JSP,而且Undertow不支持JSP.
    <ul>
      <li>Thymeleaf基础知识
  Thymeleaf是一个java类库,它是一个xml/xhtml/html5的模板引擎,可以作为MVC的Web应用的View层.
  <a href="http://www.cnblogs.com/dreamfree/p/4158557.html?utm_source=tuicool">Thymeleaf基础知识</a></li>
      <li>补充:
  在javascript中访问model</li>
    </ul>
  </li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/Spring-Boot%E7%9A%84Web%E5%BC%80%E5%8F%91.html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E5%9B%9B)-%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E5%AF%B9%E8%B1%A1-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84).html">  Pro JPA2 读书笔记系列(四) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Pro JPA2 第四章(对象-关系映射)</strong></p>

<p>把对象持久化到关系数据库的API的最大部分是对象-关系映射(Object-Relational Mapping,ORM)组件</p>

<ul>
  <li>4.1 持久化注解
  持久化注解可以应用于三个不同的级别:类,方法和字段.无论如何进行何种级别的注解,注解必须放置在所注解项目的代码定义之前.
  JPA注解设计为可读,易于指定以及有足够的灵活性以允许不同元数据的组合.大多数注解是同级指定而不是彼此嵌套的,这意味着多个注解可以注解在同一个类,字段或者属性,而不是嵌入在其他注解中进行注解.
  映射注解可以归类为两种类型:逻辑注解(logical annotation)和物理注解(physical annotation).逻辑组的注解从对象模型视图(object modeling view)描述实体模型.它们与域模型仅仅绑定.物理注解与数据库中的具有数据模型相关.它们处理表,列,约束和数据库级的其他项目.</li>
  <li>4.2 访问实体状态
    <ul>
      <li>4.2.1 字段访问
  注解实体的字段将导提供程序使用字段访问来获取和设置该实体的状态.getter和setter方法可能存在或不存在,但如果存在,将会被忽略.所有字段必须声明为受保护(protected),包(package)或私有(private).不允许使用共有字段.</li>
    </ul>
  </li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E5%9B%9B)-%E7%AC%AC%E5%9B%9B%E7%AB%A0(%E5%AF%B9%E8%B1%A1-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%BA%94)-%E7%AC%AC%E4%BA%94%E7%AB%A0(%E9%9B%86%E5%90%88%E6%98%A0%E5%B0%84).html">  Pro JPA2 读书笔记系列(五) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Pro JPA2 第五章(集合映射)</strong></p>

<ul>
  <li>5.1关系和元素集合
  映射集合实际上存在三种可以存储的对象:映射实体的,可嵌入的和基本类型的集合.
  当源实体用友一个包含目标实体类型的实例集合时,称之为一个多值关系.然儿,可嵌入的集合和基本类型的集合不是关系,它们只是元素的集合,因而称之为元素集合(element collection).关系定义了独立实体之间的关联,而元素集合包含了依赖于引用实体的对象,并且只能通过包含它们的实体进行检索.
  关系和元素集合之间的一个世纪区别在于用来表示它们的注解.关系至少要求采用关系注解,@OneToMany或者@ManyToMany,而一个元素集合是由@ElementCollection注解来标识.</li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%BA%94)-%E7%AC%AC%E4%BA%94%E7%AB%A0(%E9%9B%86%E5%90%88%E6%98%A0%E5%B0%84).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%BA%8C)-%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E5%85%A5%E9%97%A8).html">  Pro JPA2 读书笔记系列(二) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Pro JPA2 第二章(入门)</strong></p>

<p>JPA的主要目标之一是简单易用和易于理解.虽然它的问题域不容忽视或者淡化,但是解决问题的技术非常简单和直观.
本章首先将描述实体(entity)的基本特征.定义什么是实体,以及如何创建,读取,更新和删除实体.还将介绍实体管理器(EntityManager)以及如何获取和使用它们.接着,将快速了解查询(Query)以及如何使用EntityManager和Query对象指定和执行查询.然后最后会有一个总结性的小例子.</p>

<ul>
  <li>
    <p>2.1 实体概述
  实体的描述为:有特性和关系的事物,期望把它的特性和关系保存在关系数据中.实体基本上是一个名词,或者是一组状态关联在一起而形成的单个单元.在面向对象的范例中,将行为添加到实体中,并称之为对象.在JPA中,任何应用程序定义的对象都可以是一个实体.因此,一个重要问题也许是:是的对象变成实体的特征是什么?</p>

    <ul>
      <li>2.1.1 持久性
  实体的第一个和最基本的特征是它们是可持久化的.这意味着可以在一个数据存储中表示它们的装啊提,并且将来可以对他们进行访问.
  这样的实体我们称之为持久化对象(persistence object).但从技术角度来说这是不正确的.严格来讲,一个持久化对象只有在内存中实例化的时刻才变得持久.<strong>如果存在一个持久化对象,那么根据定义它已经是持久的</strong>.
  为了使实体具有持久性,应用程序必须主动地调用API方法来启动该过程.这是一个重要的区别,因为它把持久化的控制权完全留给了应用程序.
  要点是实体可能不一定必须被持久化,他们是否应该被持久化将由应用程序来决定.</li>
      <li>2.1.2 标识
  类似任何其他的Java对象,实体具有一个对象标识(identity),但是当它存在于数据库中时,还用友一个持久化标识.持久化标识,或一个标识符(identifier),是唯一标识一个实体实例并区别与其他所有相同的实体类型实例的关键.
  也就是说,在数据库表中存在一行,那么它会具有一个持久化标识,如果不在数据库中,那么,即使在内存中的实体可以在一个字段中设置标识,它也不具有持久化标识.</li>
      <li>2.1.3 事务性
  我们可以称实体为半事务性的(quasi-transactional).
  在内存中,其跟数据库的事务稍微有点不同.因为实体可能会发生改变,但这些改变并没有被持久化.</li>
      <li>2.1.4 粒度
  实体不是基本类型(primitive),基本类型封装器(primitive wrapper) 或者具有单维状态(single-dimensional state)的内置对象.这些类型都仅仅是标量(scalar),对应用程序并没有任何固有的语义含义.
  实体意味着是细粒度的对象,它包含一个聚合状态集合,他们通常存储在单个位置.最通常的意义下,它们是业务域对象,对于访问它们的应用程序具有特定含义.</li>
      <li>2.2 实体元数据
  除了其持久化的状态,每个实体都包含一些相关的元数据来描述它.这些元数据可能作为保存的类文件的一部分存在,或者可能在类的外部存储,但不是保存在数据库中.元数据是的持久化层从加载到在运行时调用实体,均能够识别,结束以及正确地管理它们.
  每个实体实际所需的元数据都是最小量的,以确保实体已于定义和使用.
  两种方式指定实体的元数据:注解(Annotation)或者XML.
        <ul>
          <li>2.2.1 注解
  元数据注解允许把结构化和类型化的元数据附加到源代码上.因为注解使得元数据与进程同时存在,所以不必转义到额外的文件和特别的语言(XML)中.</li>
          <li>2.2.2 XML
  依然可以使用XML来使用元数据</li>
          <li>2.2.3 异常配置
  异常配置(configuration by exception)的概念意味着持久化引擎定义了适用于大多数应用程序的默认值,用于只有在希望覆盖默认值时,才需要提供值.换句话说,提供配置值是规则的异常情况,而不是必需的.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>2.3 创建实体</p>
  </li>
</ul>


        </p>
        <p class="readmore">
            <a href="/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%BA%8C)-%E7%AC%AC%E4%BA%8C%E7%AB%A0(%E5%85%A5%E9%97%A8).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%B8%89)-%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F).html">  Pro JPA2 读书笔记系列(三) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Pro JPA2 第三章(企业应用程序)</strong></p>

<p>本章内容不做过多介绍.请阅读原文.</p>

<ul>
  <li>3.6 事务管理
  与任何其他类型的企业应用程序相比,使用持久化的应用程序需要更加仔细地注意事务管理的问题.事务何时开始,何时结束以及实体管理器如何参与容器托管的事务,都是开发人员使用JPA的重要主题.(事务的高级主题推荐阅读Java Transaction Processing和Principles of Transaction Processing)
    <ul>
      <li>3.6.1 事务概述
  事务是用于组合一系列操作的一个抽象.一旦分组在一起,将操作集当作单个单元,并且所有的操作必须都成功或者都不成功.
  事务的基础属性:
        <ul>
          <li>原子性(atomicity): 在一个事务中的所有操作或者都成功或者都不成功.每个操作的成功都关系到整个组的成功.</li>
          <li>一致性(consistency): 事务结束的结果状态遵循一组定义数据可接受性的规则.整个系统的数据是否合法或有效取决于系统的其余数据.</li>
          <li>隔离性(isolation): 在事务中进行的更改仅对进行更改的事务可见.一旦事务提交了更改,那么它们自动对于其他事务可见.</li>
          <li>持久性(durability):事务中所作出的更改在事务完成之后将继续保持.
  满足所欲偶这些需求的事务成为ACID事务.
  并非所有的事务都是ACID事务(例如:分布式事务),在满足ACID属性时经常会采取某种灵活性策略.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3.6.2 Java中的企业事务
    <ul>
      <li>事务划界
  每一个事务都有一个开始和结束.开始一个事务将允许后续操作成为相同事务的一部分,直至事务完成.事务可以以两种方式之一完成.可以提交它们,也可以回滚.
  引起一个事务开始或完成的行为成为事务划界(transaction demarcation).不正确的事务划界是性能退化的最常见的来源之一.
  资源本地事务总是显式地由应用程序进行划界,而容器事务既可以由容器自动划界,也可以通过使用支持应用程序划界的JTA接口进行划界.
  当容器接管事务划界责任时,我们称之为容器托管(container-managed)的事务管理;
  当应用程序负责划界时,我们称之为bean托管(bean-managed)的事务管理.</li>
      <li>容器托管的事务
  可以通过一些元数据注解来确定事务需求,并且可以在方法执行的粒度上对容器托管的事务进行配置.
  一个bean通过一个或多个方法调用另一个bean的现象很常见.在这种情况下,不会提交因为调用方法而启动的事务,因为该调用方法直到它所调用的第二个bean完成之后才会完成.这就是需要设置以定义:当方法在一个特定的事务上下文中调用时,容器应该如何行为.
  可定义的事务特性选项如下:
        <ul>
          <li>MANDATORY(强制) : 如果把该特性指定给一个方法,那么当调用该方法时,预计一个事务已经启动并处于活动状态.如果不存在活动的事务,那么将抛出一个异常.很少使用这个特性,但是当预计一个事务已经启动时,它可以作为一个开发工具以捕获事务划界的错误.</li>
          <li>REQUIRED(必需): 这个特性是最常见的情况,此时预计方法将处在一个事务中.容器确保事务对于该方法而言是活动的.如果一个事务已经是活动的,那么使用该方法;如果事务不存在,那么创建一个新事务以执行该方法.</li>
          <li>REQUIRES_NEW(必需新): 就是说每次执行这个方法,都会产生一个新的事务.</li>
          <li>SUPPORTS(支持): 标记为支持的方法不依赖于事务,但是如果事务存在的话,那么它将容忍运行在该事务当中.这将指示该方法不访问任何事务资源.</li>
          <li>NOT_SUPPORTED(不支持): 标记为不支持事务的方法,如果调用方法时存在一个活动事务,那么将导致容器暂停当前事务.这意味着该方法不执行事务操作,但当其他方法可能不合期望地影响到事务结果时,可能会导致失败.此特性不常用.</li>
          <li>NEVER(永远不):标记为永远不支持事务的方法,如果当电泳该方法时存在活动的事务,那么将导致容器抛出异常.</li>
        </ul>
      </li>
      <li>bean托管的事务
  bean托管的事务(Bean-Managed Transaction,BMT).使用BMT的bean必须确保一旦已经启动了一个事务,就必须在启动它的方法返回之前完成它.(考虑多线程). 不这么做将导致容器自动回滚事务并抛出一个异常.
  由应用程序而不是由容器托管事务的一个不利之处在于它们不会传播到由另一个BMT bean调用的方法.</li>
    </ul>
  </li>
</ul>

        </p>
        <p class="readmore">
            <a href="/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%B8%89)-%E7%AC%AC%E4%B8%89%E7%AB%A0(%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>

<article class="preview">
    <header>
        <h2 class="post-title">
            <a href="/blog/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%B8%80)-%E7%AC%AC%E4%B8%80%E7%AB%A0(%E7%AE%80%E4%BB%8B).html">  Pro JPA2 读书笔记系列(一) </a>
        </h2>
        <p class="post-time"> 2016年08月28日 星期六</p>
    </header>
    <section class="post-section">
        <p>
            <p><strong>Pro JPA2 第一章(简介)</strong></p>

<p>目前世界上的企业数据,绝大多数存储在关系数据库中.
理解关系数据是企业开发成功的关键.
Java成功的很大一部分应该归功于,其被广泛的用于构建企业数据库系统.
但是,在数据库系统和Java应用程序的对象模型之间来回地移动数据,比实际所需困难的多.Java开发人员或者需要编写大量的代码,将行和列数据转换成对象,或者发现自己被绑定到某些专用的架构中,这些架构试图对他们隐藏数据库.
幸运的是,我们Java有了JPA,以构建面向对象的域模型和关系数据库系统之间的桥梁.
JPA的优势之一是,可以将它插入到应用程序所需的任何层,级,或者架构中.</p>

<ul>
  <li>1.1 对象-关系映射
用于在对象模型和关系模型之间搭建桥梁的技术,称为对象-关系映射(object-relational mapping),通常表示为O-R映射或者简写为ORM.该术语来源于这样的思想:我们正在以某种方式将一个模型的概念映射到另一个模型,目标是引入一个中介来管理一个模型到另一个模型的自动转换.
在此之前,先定义一下什么是理想的解决方案.
    <ul>
      <li>对象,而不是表.应用程序应该依据域模型进行开发,而无需绑定到关系模型.必须能够在域模型上操作和查询,无须表示成关系语言的表,列以及外键.</li>
      <li>方便,但非无知.ORM适用于那些已经理解了映射问题,并且知道他们所需的开发人员,这些开发人员不想编写成千上万行代码来处理已经解决的问题.</li>
      <li>不显著,但非透明.期望持久化是透明的是不合理的,因为应用程序总是需要控制它正在持久化的对象,并且关注实体的生命周期.然后,持久化解决方案不应当干扰域模型,不必要求扩展类或者实现接口是可持久化的.</li>
      <li>旧数据,新对象.与创建一个新的数据库架构相比,应用程序更加可能链接到已经存在的关系数据库架构中.</li>
      <li>充分,但不过分.功能足够就好,但不能因为功能太强而引入太多的系统开销.</li>
      <li>本地,但可移动.包含持久化状态的实体必须能够移动到任何需要它们的层.</li>
    </ul>

    <p><strong>阻抗失谐</strong>
  对象-关系映射的倡议者通常把对象模型和关系模型之间的差异描述为两者之间的阻抗失谐(impedance mismatch).
  将一个模型映射到另一个模型的挑战不在于两者之间的相似性,而在于每个模型中存在一些概念,这些概念在另外一个模型中没有任何逻辑等价物.
  * 从类的表示来看.有些敏感信息或者明显可以单独建表的信息,在数据库架构设计中,不一定是在同一张表中.这种情况也发生在一张表的某一个字段当中.例如,一个人的出生年月,是用一个birthday字段来表示,还是用三个字段年,月,日来表示.
  * 从关系的角度来看.表与表,实体与实体之间的关系有一对一,一对多,多对多,多对一等各种复杂的关系,而且关联实体或者关联表中又会有其他关联.我们在代码开发的过程中,必须面对这种情况,而且还要面对主键不在对象 模型中,以及在模型中必须引入额外关系甚至关联类以补偿数据库架构的可能性.
  * 从继承的角度看,对象-关系映射不再只是处理从一个类到一个表有一个自然映射的情况.在抽象出超类或者父类的时候,引入了将简单问题复杂化的可能性.</p>
  </li>
  <li>1.2 Java持久化支持.(略)
    <ul>
      <li>1.2.1 专用解决方案.Oracle TopLink等</li>
      <li>1.2.2 JDBC</li>
      <li>1.2.3 企业Bean(EJB)</li>
      <li>1.2.4 Java数据对象(JDO)</li>
    </ul>
  </li>
  <li>1.3 为什么需要另一种标准.(略)</li>
  <li>1.4 Java持久化API
  Java持久化API(Java Persistence API) 是轻量级的,基于POJO的用于Java持久化的架构.
    <ul>
      <li>1.4.1 规范的历史
        <ul>
          <li>EJB3.0和JPA1.0.(略)</li>
          <li>JPA 2.0.(略)</li>
          <li>JPA和您.(略)</li>
        </ul>
      </li>
      <li>1.4.2 概述
        <ul>
          <li>POJO持久化
  使用POJO进行对象的持久化意味着任何持久化的对象都没有什么特殊之处.
  使用JPA的对象-关系映射完全是元数据驱动的.可以通过把注解添加到代码中,或者使用外部定义的XML来实现它.</li>
          <li>非干扰性
  持久化API作为一个与持久化对象独立的层存在.持久化API有应用程序业务逻辑所调用,并传递持久化对象以及相应的操作指示.因为API不干扰在持久化对象类中的代码,所以我们称之为非干扰式的持久化(non-intrusive persistence).</li>
          <li>对象查询
  一个强大的查询架构提供了能够跨越实体和关系的查询能力,而不必使用具体的外键或者数据库列.
  查询跨越表示为Java持久化查询语言(JP QL)也可以表示为一个机遇实体模型的架构抽象.</li>
          <li>移动实体
  离开持久化层的对象称为是分离的.持久化模型的一个关键功能是鞥能够改变分离的实体,然后在它们返回时重新连接到虚拟机.该分离模型提供了一个方法,使得可以协调实体重新连接时的状态与它编程分离之前的状态.从而,荀彧离线改变实体,同时在面临并发时仍然保持实体的一致性.</li>
          <li>简单配置.
  所有功能都可以通过使用注解,xml,或者两者结合的组合来配置.
  相比元数据语言,更大的意义在于JPA使用大量默认值的事实.这意味着无论选择何种方法,都要求用于保证运行的元数据的数量绝对是最少的.如果默认已足够满足要求,那么几乎根本不需要任何元数据.</li>
          <li>集成性和可测试性.
  利用Java持久化API,现在可以编写服务器集成的九成九代码,并能够重用它以在服务器外部进行测试.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

        </p>
        <p class="readmore">
            <a href="/2016/08/28/Pro-JPA2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97(%E4%B8%80)-%E7%AC%AC%E4%B8%80%E7%AB%A0(%E7%AE%80%E4%BB%8B).html">
                阅读全文
                <span class="glyphicon glyphicon-circle-arrow-right"></span>
            </a>
        </p>
    </section>

</article>


    </main>

    <div class="footer-copyright">
    <div class="container-fluid">
        <div class="row-fluid">
            <div class="col-md-12">
                Copyright &copy; 2016 王 - All rights reserved.
            </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="/blog/assets/js/jquery.min.js"></script>
<script type="text/javascript" src="/blog/assets/js/bootstrap.min.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74743250-2', 'auto');
  ga('send', 'pageview');

</script>


  </body>

</html>
